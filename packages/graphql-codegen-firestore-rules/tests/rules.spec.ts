import { buildSchema } from 'graphql'
import { plugin } from '../src'

describe('@firebase-graphql/graphql-codegen-firestore-rules', () => {
  test('Absolutely successful', () => {
    expect(true).toBeTruthy()
  })

  const rulesTemplate = (
    content: string,
  ) => `// Generated by GraphQL Firestore Rules
rules_version = "2"
service cloud.firestore {
  match /databases/{database}/documents {
    function isString(value) {
      return value is string
    }
    function isInt(value) {
      return value is int
    }
    function isBoolean(value) {
      return value is bool
    }
    function isFloat(value) {
      return value is float
    }
    function isID(value) {
      return value is string
    }
    function isDate(value) {
      return value is timestamp
    }
    function isMap(value) {
      return value is map
    }
    function isRequired(source, field) {
      return field in source && source[field] != null
    }
    function isNullable(source, field) {
      return !(field in source) || source[field] == null
    }
    function isLoggedIn() {
      return request.auth != null
    }
    function isAuthUserId(userId) {
      return isLoggedIn() && request.auth.uid == userId
    }${content}  }
}
`

  test('empty schema', async () => {
    const schema = buildSchema(/* GraphQL */ `
      scalar Date
    `)
    const result = await plugin(schema, [], {})
    expect(result).toBe(
      rulesTemplate(`
`),
    )
  })

  describe('validators', () => {
    describe('string field validator', () => {
      test('required', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            name: String!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "name") && isString(value.name)
      )
    }
`),
        )
      })
      test('optional', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            name: String
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
`),
        )
      })
    })

    describe('int field validator', () => {
      test('required', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            age: Int!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "age"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "age") && isInt(value.age)
      )
    }
`),
        )
      })
      test('optional', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            age: Int
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "age"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "age") || isInt(value.age))
      )
    }
`),
        )
      })
    })

    describe('boolean field validator', () => {
      test('required', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            isStaff: Boolean!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "isStaff"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "isStaff") && isBoolean(value.isStaff)
      )
    }
`),
        )
      })
      test('optional', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            isStaff: Boolean
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "isStaff"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "isStaff") || isBoolean(value.isStaff))
      )
    }
`),
        )
      })
    })

    describe('float field validator', () => {
      test('required', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            score: Float!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "score"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "score") && isFloat(value.score)
      )
    }
`),
        )
      })
      test('optional', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            score: Float
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "score"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "score") || isFloat(value.score))
      )
    }
`),
        )
      })
    })

    describe('id field validator', () => {
      test('required', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            id: ID!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "id"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "id") && isID(value.id)
      )
    }
`),
        )
      })
      test('optional', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            id: ID
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "id"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "id") || isID(value.id))
      )
    }
`),
        )
      })
    })

    describe('date field validator', () => {
      test('required', async () => {
        const schema = buildSchema(/* GraphQL */ `
          scalar Date
          type User {
            createdAt: Date!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "createdAt"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "createdAt") && isDate(value.createdAt)
      )
    }
`),
        )
      })
      test('optional', async () => {
        const schema = buildSchema(/* GraphQL */ `
          scalar Date
          type User {
            createdAt: Date
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "createdAt"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "createdAt") || isDate(value.createdAt))
      )
    }
`),
        )
      })
    })

    describe('enum field validator', () => {
      test('validate enum function', async () => {
        const schema = buildSchema(/* GraphQL */ `
          enum Language {
            PYTHON
            JAVASCRIPT
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isLanguage(value) {
      return isString(value) && value in ["PYTHON", "JAVASCRIPT"]
    }
`),
        )
      })
      test('required enum', async () => {
        const schema = buildSchema(/* GraphQL */ `
          enum Language {
            PYTHON
            JAVASCRIPT
          }
          type User {
            language: Language!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isLanguage(value) {
      return isString(value) && value in ["PYTHON", "JAVASCRIPT"]
    }
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "language"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "language") && isLanguage(value.language)
      )
    }
`),
        )
      })
      test('optional enum', async () => {
        const schema = buildSchema(/* GraphQL */ `
          enum Language {
            PYTHON
            JAVASCRIPT
          }
          type User {
            language: Language
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isLanguage(value) {
      return isString(value) && value in ["PYTHON", "JAVASCRIPT"]
    }
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "language"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "language") || isLanguage(value.language))
      )
    }
`),
        )
      })
    })

    describe('type field validator', () => {
      test('validate type function', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            name: String!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "name") && isString(value.name)
      )
    }
`),
        )
      })
      test('required', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            name: String!
          }
          type Post {
            author: User!
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "name") && isString(value.name)
      )
    }
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "author"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "author") && isUser(value.author)
      )
    }
`),
        )
      })
      test('optional', async () => {
        const schema = buildSchema(/* GraphQL */ `
          type User {
            name: String!
          }
          type Post {
            author: User
          }
        `)
        const result = await plugin(schema, [], {})
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && isRequired(value, "name") && isString(value.name)
      )
    }
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "author"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && (isNullable(value, "author") || isUser(value.author))
      )
    }
`),
        )
      })
    })
  })

  describe('ignore path field', () => {
    test('document id', async () => {
      const schema = buildSchema(
        /* GraphQL */ `
          type User @firestore(document: "/users/{id}") {
            id: ID!
            name: String
          }
        `,
        { assumeValid: true },
      )
      const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
      expect(result).toBe(
        rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
      )
      allow update: if (
        isUser(request.resource.data)
      )
    }
`),
      )
    })

    test('nest document', async () => {
      const schema = buildSchema(
        /* GraphQL */ `
          type Post @firestore(document: "/users/{userId}/posts/{id}") {
            id: ID!
            userId: ID!
            title: String
          }
        `,
        { assumeValid: true },
      )
      const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
      expect(result).toBe(
        rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /users/{userId}/posts/{id} {
      allow create: if (
        isPost(request.resource.data)
      )
      allow update: if (
        isPost(request.resource.data)
      )
    }
`),
      )
    })
  })

  describe('match expression', () => {
    test('one type', async () => {
      const schema = buildSchema(
        /* GraphQL */ `
          type User @firestore(document: "/users/{id}") {
            id: ID!
            name: String
          }
        `,
        { assumeValid: true },
      )
      const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
      expect(result).toBe(
        rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
      )
      allow update: if (
        isUser(request.resource.data)
      )
    }
`),
      )
    })

    test('multiple types', async () => {
      const schema = buildSchema(
        /* GraphQL */ `
          type User @firestore(document: "/users/{id}") {
            id: ID!
            name: String
          }

          type Post @firestore(document: "/users/{userId}/posts/{id}") {
            id: ID!
            userId: ID!
            title: String
          }
        `,
        { assumeValid: true },
      )
      const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
      expect(result).toBe(
        rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
      )
      allow update: if (
        isUser(request.resource.data)
      )
    }
    match /users/{userId}/posts/{id} {
      allow create: if (
        isPost(request.resource.data)
      )
      allow update: if (
        isPost(request.resource.data)
      )
    }
`),
      )
    })
  })

  describe('allow expression', () => {
    describe('"@createdAt" and "@updatedAt" directives', () => {
      test('only one "@createdAt" directive', async () => {
        const schema = buildSchema(
          /* GraphQL */ `
            scalar Date
            type User @firestore(document: "/users/{id}") {
              id: ID!
              name: String
              createdAt: Date! @createdAt
            }
          `,
          { assumeValid: true },
        )
        const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name", "createdAt"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
        && isRequired(value, "createdAt") && isDate(value.createdAt)
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
        && request.resource.data.createdAt == request.time
      )
      allow update: if (
        isUser(request.resource.data)
        && !("createdAt" in request.resource.data)
      )
    }
`),
        )
      })

      test('only one "@updatedAt" directive', async () => {
        const schema = buildSchema(
          /* GraphQL */ `
            scalar Date
            type User @firestore(document: "/users/{id}") {
              id: ID!
              name: String
              updatedAt: Date! @updatedAt
            }
          `,
          { assumeValid: true },
        )
        const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name", "updatedAt"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
        && isRequired(value, "updatedAt") && isDate(value.updatedAt)
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
        && request.resource.data.updatedAt == request.time
      )
      allow update: if (
        isUser(request.resource.data)
        && request.resource.data.updatedAt == request.time
      )
    }
`),
        )
      })

      test('"@created" and "@updatedAt" directive', async () => {
        const schema = buildSchema(
          /* GraphQL */ `
            scalar Date
            type User @firestore(document: "/users/{id}") {
              id: ID!
              name: String
              createdAt: Date! @createdAt
              updatedAt: Date! @updatedAt
            }
          `,
          { assumeValid: true },
        )
        const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name", "createdAt", "updatedAt"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
        && isRequired(value, "createdAt") && isDate(value.createdAt)
        && isRequired(value, "updatedAt") && isDate(value.updatedAt)
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
        && request.resource.data.createdAt == request.time
        && request.resource.data.updatedAt == request.time
      )
      allow update: if (
        isUser(request.resource.data)
        && !("createdAt" in request.resource.data)
        && request.resource.data.updatedAt == request.time
      )
    }
`),
        )
      })

      test(`two "@createdAt" directives`, async () => {
        const schema = buildSchema(
          /* GraphQL */ `
            scalar Date
            type User @firestore(document: "/users/{id}") {
              id: ID!
              name: String
              createdAt: Date! @createdAt
              otherCreatedAt: Date! @createdAt
            }
          `,
          { assumeValid: true },
        )
        const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name", "createdAt", "otherCreatedAt"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
        && isRequired(value, "createdAt") && isDate(value.createdAt)
        && isRequired(value, "otherCreatedAt") && isDate(value.otherCreatedAt)
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
        && request.resource.data.createdAt == request.time
        && request.resource.data.otherCreatedAt == request.time
      )
      allow update: if (
        isUser(request.resource.data)
        && !("createdAt" in request.resource.data)
        && !("otherCreatedAt" in request.resource.data)
      )
    }
`),
        )
      })

      test(`two "@updateAt" directives`, async () => {
        const schema = buildSchema(
          /* GraphQL */ `
            scalar Date
            type User @firestore(document: "/users/{id}") {
              id: ID!
              name: String
              updatedAt: Date! @updatedAt
              otherUpdatedAt: Date! @updatedAt
            }
          `,
          { assumeValid: true },
        )
        const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name", "updatedAt", "otherUpdatedAt"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
        && isRequired(value, "updatedAt") && isDate(value.updatedAt)
        && isRequired(value, "otherUpdatedAt") && isDate(value.otherUpdatedAt)
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
        && request.resource.data.updatedAt == request.time
        && request.resource.data.otherUpdatedAt == request.time
      )
      allow update: if (
        isUser(request.resource.data)
        && request.resource.data.updatedAt == request.time
        && request.resource.data.otherUpdatedAt == request.time
      )
    }
`),
        )
      })
    })

    describe('@auth directive', () => {
      test('empty rules', async () => {
        const schema = buildSchema(
          /* GraphQL */ `
            type User @firestore(document: "/users/{id}") @auth(rules: []) {
              id: ID!
              name: String
            }
          `,
          { assumeValid: true },
        )
        const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
        expect(result).toBe(
          rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
    }
`),
        )
      })

      describe('private', () => {
        test('get', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: private, operations: [get] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow get: if (
        isLoggedIn()
      )
    }
`),
          )
        })
        test('list', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: private, operations: [list] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow list: if (
        isLoggedIn()
      )
    }
`),
          )
        })
        test('create', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: private, operations: [create] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
        && isLoggedIn()
      )
    }
`),
          )
        })
        test('update', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: private, operations: [update] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow update: if (
        isUser(request.resource.data)
        && isLoggedIn()
      )
    }
`),
          )
        })
        test('delete', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: private, operations: [delete] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow delete: if (
        isLoggedIn()
      )
    }
`),
          )
        })
        test('all', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(
                  rules: [
                    {
                      allow: private
                      operations: [get, list, create, update, delete]
                    }
                  ]
                ) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], { ignoreNoAuthWarning: true })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow get: if (
        isLoggedIn()
      )
      allow list: if (
        isLoggedIn()
      )
      allow create: if (
        isUser(request.resource.data)
        && isLoggedIn()
      )
      allow update: if (
        isUser(request.resource.data)
        && isLoggedIn()
      )
      allow delete: if (
        isLoggedIn()
      )
    }
`),
          )
        })
      })

      describe('owner', () => {
        describe('owner field by path mapping', () => {
          test('get', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type User
                  @firestore(document: "/users/{id}")
                  @auth(
                    rules: [
                      { allow: owner, operations: [get], ownerField: "id" }
                    ]
                  ) {
                  id: ID!
                  name: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow get: if (
        isAuthUserId(id)
      )
    }
`),
            )
          })
          test('list', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type User
                  @firestore(document: "/users/{id}")
                  @auth(
                    rules: [
                      { allow: owner, operations: [list], ownerField: "id" }
                    ]
                  ) {
                  id: ID!
                  name: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow list: if (
        isAuthUserId(id)
      )
    }
`),
            )
          })
          test('create', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type User
                  @firestore(document: "/users/{id}")
                  @auth(
                    rules: [
                      { allow: owner, operations: [create], ownerField: "id" }
                    ]
                  ) {
                  id: ID!
                  name: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
        && isAuthUserId(id)
      )
    }
`),
            )
          })
          test('update', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type User
                  @firestore(document: "/users/{id}")
                  @auth(
                    rules: [
                      { allow: owner, operations: [update], ownerField: "id" }
                    ]
                  ) {
                  id: ID!
                  name: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow update: if (
        isUser(request.resource.data)
        && isAuthUserId(id)
      )
    }
`),
            )
          })
          test('delete', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type User
                  @firestore(document: "/users/{id}")
                  @auth(
                    rules: [
                      { allow: owner, operations: [delete], ownerField: "id" }
                    ]
                  ) {
                  id: ID!
                  name: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow delete: if (
        isAuthUserId(id)
      )
    }
`),
            )
          })
          test('all', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type User
                  @firestore(document: "/users/{id}")
                  @auth(
                    rules: [
                      {
                        allow: owner
                        operations: [get, list, create, update, delete]
                        ownerField: "id"
                      }
                    ]
                  ) {
                  id: ID!
                  name: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow get: if (
        isAuthUserId(id)
      )
      allow list: if (
        isAuthUserId(id)
      )
      allow create: if (
        isUser(request.resource.data)
        && isAuthUserId(id)
      )
      allow update: if (
        isUser(request.resource.data)
        && isAuthUserId(id)
      )
      allow delete: if (
        isAuthUserId(id)
      )
    }
`),
            )
          })
        })
        describe('owner field by data', () => {
          test('get', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type Post
                  @firestore(document: "/posts/{id}")
                  @auth(
                    rules: [
                      { allow: owner, operations: [get], ownerField: "userId" }
                    ]
                  ) {
                  id: ID!
                  userId: ID!
                  title: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "userId", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "userId") && isID(value.userId)
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /posts/{id} {
      allow get: if (
        isAuthUserId(resource.data.userId)
      )
    }
`),
            )
          })
          test('list', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type Post
                  @firestore(document: "/posts/{id}")
                  @auth(
                    rules: [
                      { allow: owner, operations: [list], ownerField: "userId" }
                    ]
                  ) {
                  id: ID!
                  userId: ID!
                  title: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "userId", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "userId") && isID(value.userId)
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /posts/{id} {
      allow list: if (
        isAuthUserId(resource.data.userId)
      )
    }
`),
            )
          })
          test('create', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type Post
                  @firestore(document: "/posts/{id}")
                  @auth(
                    rules: [
                      {
                        allow: owner
                        operations: [create]
                        ownerField: "userId"
                      }
                    ]
                  ) {
                  id: ID!
                  userId: ID!
                  title: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "userId", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "userId") && isID(value.userId)
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /posts/{id} {
      allow create: if (
        isPost(request.resource.data)
        && isAuthUserId(request.resource.data.userId)
      )
    }
`),
            )
          })
          test('update', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type Post
                  @firestore(document: "/posts/{id}")
                  @auth(
                    rules: [
                      {
                        allow: owner
                        operations: [update]
                        ownerField: "userId"
                      }
                    ]
                  ) {
                  id: ID!
                  userId: ID!
                  title: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "userId", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "userId") && isID(value.userId)
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /posts/{id} {
      allow update: if (
        isPost(request.resource.data)
        && (isAuthUserId(request.resource.data.userId) && isAuthUserId(resource.data.userId))
      )
    }
`),
            )
          })
          test('delete', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type Post
                  @firestore(document: "/posts/{id}")
                  @auth(
                    rules: [
                      {
                        allow: owner
                        operations: [delete]
                        ownerField: "userId"
                      }
                    ]
                  ) {
                  id: ID!
                  userId: ID!
                  title: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "userId", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "userId") && isID(value.userId)
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /posts/{id} {
      allow delete: if (
        isAuthUserId(resource.data.userId)
      )
    }
`),
            )
          })
          test('all', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type Post
                  @firestore(document: "/posts/{id}")
                  @auth(
                    rules: [
                      {
                        allow: owner
                        operations: [get, list, create, update, delete]
                        ownerField: "userId"
                      }
                    ]
                  ) {
                  id: ID!
                  userId: ID!
                  title: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "userId", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "userId") && isID(value.userId)
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /posts/{id} {
      allow get: if (
        isAuthUserId(resource.data.userId)
      )
      allow list: if (
        isAuthUserId(resource.data.userId)
      )
      allow create: if (
        isPost(request.resource.data)
        && isAuthUserId(request.resource.data.userId)
      )
      allow update: if (
        isPost(request.resource.data)
        && (isAuthUserId(request.resource.data.userId) && isAuthUserId(resource.data.userId))
      )
      allow delete: if (
        isAuthUserId(resource.data.userId)
      )
    }
`),
            )
          })
        })
      })
      describe('public', () => {
        test('get', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: public, operations: [get] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], {
            ignoreNoAuthWarning: true,
          })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow get: if (
        true
      )
    }
`),
          )
        })
        test('list', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: public, operations: [list] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], {
            ignoreNoAuthWarning: true,
          })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow list: if (
        true
      )
    }
`),
          )
        })
        test('create', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: public, operations: [create] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], {
            ignoreNoAuthWarning: true,
          })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow create: if (
        isUser(request.resource.data)
        && true
      )
    }
`),
          )
        })
        test('update', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: public, operations: [update] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], {
            ignoreNoAuthWarning: true,
          })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow update: if (
        isUser(request.resource.data)
        && true
      )
    }
`),
          )
        })
        test('delete', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(rules: [{ allow: public, operations: [delete] }]) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], {
            ignoreNoAuthWarning: true,
          })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow delete: if (
        true
      )
    }
`),
          )
        })
        test('all', async () => {
          const schema = buildSchema(
            /* GraphQL */ `
              type User
                @firestore(document: "/users/{id}")
                @auth(
                  rules: [
                    {
                      allow: public
                      operations: [get, list, create, update, delete]
                    }
                  ]
                ) {
                id: ID!
                name: String
              }
            `,
            { assumeValid: true },
          )
          const result = await plugin(schema, [], {
            ignoreNoAuthWarning: true,
          })
          expect(result).toBe(
            rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow get: if (
        true
      )
      allow list: if (
        true
      )
      allow create: if (
        isUser(request.resource.data)
        && true
      )
      allow update: if (
        isUser(request.resource.data)
        && true
      )
      allow delete: if (
        true
      )
    }
`),
          )
        })
      })
      describe('with multiple rules', () => {
        describe('with same allow and same operations', () => {
          test('private and owner by path with get method', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type User
                  @firestore(document: "/users/{id}")
                  @auth(
                    rules: [
                      { allow: private, operations: [get] }
                      { allow: owner, operations: [get], ownerField: "id" }
                    ]
                  ) {
                  id: ID!
                  name: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    match /users/{id} {
      allow get: if (
        (isLoggedIn()
        || isAuthUserId(id))
      )
    }
`),
            )
          })
          test('private and owner by data with create method', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type Post
                  @firestore(document: "/posts/{id}")
                  @auth(
                    rules: [
                      { allow: private, operations: [create] }
                      {
                        allow: owner
                        operations: [create]
                        ownerField: "userId"
                      }
                    ]
                  ) {
                  id: ID!
                  userId: ID!
                  title: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "userId", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "userId") && isID(value.userId)
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /posts/{id} {
      allow create: if (
        isPost(request.resource.data)
        && (isLoggedIn()
        || isAuthUserId(request.resource.data.userId))
      )
    }
`),
            )
          })
          test('private, owner by path and owner by data with create and update method', async () => {
            const schema = buildSchema(
              /* GraphQL */ `
                type Post
                  @firestore(document: "/posts/{id}")
                  @auth(
                    rules: [
                      { allow: private, operations: [create, update] }
                      {
                        allow: owner
                        operations: [create, update]
                        ownerField: "userId"
                      }
                      {
                        allow: owner
                        operations: [create, update]
                        ownerField: "id"
                      }
                    ]
                  ) {
                  id: ID!
                  userId: ID!
                  title: String
                }
              `,
              { assumeValid: true },
            )
            const result = await plugin(schema, [], {
              ignoreNoAuthWarning: true,
            })
            expect(result).toBe(
              rulesTemplate(`
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "userId", "title"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && isRequired(value, "userId") && isID(value.userId)
        && (isNullable(value, "title") || isString(value.title))
      )
    }
    match /posts/{id} {
      allow create: if (
        isPost(request.resource.data)
        && (isLoggedIn()
        || isAuthUserId(request.resource.data.userId)
        || isAuthUserId(id))
      )
      allow update: if (
        isPost(request.resource.data)
        && (isLoggedIn()
        || (isAuthUserId(request.resource.data.userId) && isAuthUserId(resource.data.userId))
        || isAuthUserId(id))
      )
    }
`),
            )
          })
        })
      })
    })
  })

  describe('complete examples', () => {
    test('user, post and tag', async () => {
      const schema = buildSchema(
        /* GraphQL */ `
          enum Tag {
            SPORT
            TECHNOLOGY
            POLITICS
          }
          type User
            @firestore(document: "/users/{id}")
            @auth(
              rules: [
                { allow: public, operations: [get, list] }
                { allow: owner, operations: [create, update], ownerField: "id" }
              ]
            ) {
            id: ID!
            name: String
          }

          type Post
            @firestore(document: "/users/{userId}/posts/{id}")
            @auth(
              rules: [
                {
                  allow: owner
                  operations: [create, update, delete]
                  ownerField: "userId"
                }
                { allow: public, operations: [get, list] }
              ]
            ) {
            id: ID!
            userId: ID!
            title: String
            tag: Tag
          }
        `,
        { assumeValid: true },
      )
      const result = await plugin(schema, [], {
        ignoreNoAuthWarning: true,
      })
      expect(result).toBe(
        rulesTemplate(`
    function isTag(value) {
      return isString(value) && value in ["SPORT", "TECHNOLOGY", "POLITICS"]
    }
    function isUser(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "name"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "User"
        && (isNullable(value, "name") || isString(value.name))
      )
    }
    function isPost(value) {
      return (
        isMap(value) && value.keys().hasOnly(["__typename", "title", "tag"])
        && isRequired(value, "__typename") && isString(value.__typename) && value.__typename == "Post"
        && (isNullable(value, "title") || isString(value.title))
        && (isNullable(value, "tag") || isTag(value.tag))
      )
    }
    match /users/{id} {
      allow get: if (
        true
      )
      allow list: if (
        true
      )
      allow create: if (
        isUser(request.resource.data)
        && isAuthUserId(id)
      )
      allow update: if (
        isUser(request.resource.data)
        && isAuthUserId(id)
      )
    }
    match /users/{userId}/posts/{id} {
      allow get: if (
        true
      )
      allow list: if (
        true
      )
      allow create: if (
        isPost(request.resource.data)
        && isAuthUserId(userId)
      )
      allow update: if (
        isPost(request.resource.data)
        && isAuthUserId(userId)
      )
      allow delete: if (
        isAuthUserId(userId)
      )
    }
`),
      )
    })
  })
})
